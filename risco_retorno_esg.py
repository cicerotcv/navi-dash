# -*- coding: utf-8 -*-
"""Risco Retorno ESG.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QdzLmMWg4ei15OLvYXxMLfj5Ek4OfSqY

Autor: Time 18

Cicero 

Eric

# 1. Instalando e importando bibliotecas
"""

!pip install yfinance

import yfinance as yf

!pip install investpy
import investpy

import pandas as pd
import numpy as np

investpy.get_indices_list('brazil')

"""# 2. Importando dados"""

ativos = ['CMIG4.SA','CPFE3.SA', 'CPFE3.SA', 'ELET6.SA', 'NEOE3.SA', 'CPLE6.SA', 'ENBR3.SA', 'EGIE3.SA','TRPL4.SA','TAEE11.SA', 'EQTL3.SA']

inicio = '2021-01-01'
fim = '2021-09-15'

iniciobr = '01/01/2021'
fimbr = '12/09/2021'

df = pd.DataFrame()

for i in ativos: 
  df[i] = yf.download(i, start = inicio, end = fim)['Adj Close']

precos = df

precos.head()

precos.plot(figsize = (10,10));

normalizado = precos/precos.iloc[0]

normalizado.plot(figsize = (10,10));

normalizado['CMIG4.SA'].plot();

"""# 3. Cálculo dos retornos"""

ativos_retornos = precos.pct_change()

ativos_retornos.head()

ativos_retornos = ativos_retornos.dropna()

ativos_retornos.plot(figsize = (10,10));

"""# 4. Visualização de janela de volatilidade"""

vol_movel = ativos_retornos.rolling(window = 20).std()

vol_movel.plot(figsize = (10,10));

"""# 5. Criando um DF consolidado com retorno vs. volatilidade"""

ativos_retornos.std()

volatilidade = pd.DataFrame(ativos_retornos.std(), columns= ['Vol'] )

retornos_medios = pd.DataFrame(ativos_retornos.mean(), columns= ['Returns'] )

risco_retorno = pd.concat([retornos_medios, volatilidade], axis = 1)

risco_retorno

import seaborn as sns
import matplotlib.pyplot as plt

risco_retorno.shape[0]

range(risco_retorno.shape[0])

plt.subplots(figsize = (12,10))

sns.scatterplot(data = risco_retorno, x = 'Vol', y = 'Returns')

for i in range(risco_retorno.shape[0]):
  plt.text(x = risco_retorno.Vol[i], y = risco_retorno.Returns[i], s = risco_retorno.index[i],
           fontdict = dict(color = 'red', size = 14),
           bbox = dict(facecolor = 'yellow'))

"""## 6. Simulação de uma carteira vs. IBOV"""

primeira = precos.iloc[0]

#Investe 1mm em cada
comprados = round(1000000/primeira, 0)
comprados

PL = precos*comprados

PL.tail()

PL['PL Total'] = PL.iloc[:].sum(axis = 1)

PL.head()

PL.tail()

iee = investpy.get_index_historical_data('Electrical Energy', country= 'brazil',from_date=iniciobr, to_date=fimbr)
iee

iee.rename(columns = {'Close': 'IEE B3'}, inplace = True)
iee.head()

iee = iee.drop(iee.columns[[0,1,2,4,5]], axis = 1)

iee

PL.index = pd.to_datetime(PL.index)

novo_df = pd.merge(iee, PL, how = 'inner', on = 'Date')

novo_df.head()

PL_normalizado = novo_df/novo_df.iloc[0]

PL_normalizado.head()

PL_normalizado.tail()

PL_normalizado.to_json('GraficoPLTotaleIndiceIEEB3Comparado.json')

#Evidência legal. Normalizando, a carteira selecionada teve desempenho superior :)

PL_normalizado[['IEE B3', 'PL Total']].plot(figsize = (10,10));

